# terraform/main.tf
terraform {
 required_providers {
   azurerm = {
     source  = "hashicorp/azurerm"
     version = "~> 3.0"
   }
 }
 required_version = ">= 1.0"
}

# Configure the Azure Provider with better resource deletion handling
provider "azurerm" {
 features {
   resource_group {
     prevent_deletion_if_contains_resources = false
   }
   key_vault {
     purge_soft_delete_on_destroy = true
     recover_soft_deleted_key_vaults = true
   }
 }
 # Assumes authentication via Azure CLI (run `az login`)
}

# --- Resource Definitions (Hardcoded) ---

# 1. Resource Group
resource "azurerm_resource_group" "rg" {
 name     = "iot-azure-rg-1746834279" # Updated resource group name
 location = "eastus2"
 
 # Add explicit timeouts for better control
 timeouts {
   create = "30m"
   delete = "30m"
 }
}

# 2. ADLS Gen2 Storage Account
resource "random_string" "storage_suffix" {
  length  = 6
  special = false
  upper   = false
}

resource "azurerm_storage_account" "sa" {
  name                     = "iotlearn2024${random_string.storage_suffix.result}"
  resource_group_name      = azurerm_resource_group.rg.name
  location                 = azurerm_resource_group.rg.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
  is_hns_enabled           = false
  
  static_website {
    index_document     = "index.html"
    error_404_document = "error404.html"
  }
  
  timeouts {
    create = "60m"
    delete = "30m"
  }
}

# 3. Storage Container
resource "azurerm_storage_container" "raw_data_container" {
 name                  = "rawdata"
 storage_account_name  = azurerm_storage_account.sa.name
 container_access_type = "private"
}

# 4. App Service Plan (Linux)
resource "azurerm_service_plan" "asp" {
 name                = "iot-azure-asp" # Simple hardcoded name
 resource_group_name = azurerm_resource_group.rg.name
 location            = azurerm_resource_group.rg.location
 os_type             = "Linux"
 sku_name            = "B1" # Basic tier
 
 # Add explicit timeouts
 timeouts {
   create = "30m"
   delete = "30m"
 }
}

# 5. App Service (Linux Web App for .NET API)
resource "azurerm_linux_web_app" "api_app" {
 name                = "iot-azure-api-app-ned" # Consider making this dynamic/variable
 resource_group_name = azurerm_resource_group.rg.name
 location            = azurerm_resource_group.rg.location
 service_plan_id     = azurerm_service_plan.asp.id

 identity {
   type = "SystemAssigned"
 }

 site_config {
   application_stack {
     dotnet_version = "8.0" # Assuming .NET 8
   }
   always_on = false
 }

 app_settings = {
   # !! INSECURE - Hardcoded key for initial testing only !!
   # Consider using Key Vault reference later: "@Microsoft.KeyVault(SecretUri=...)"
   "APP_API_KEY"            = "SuperSecretKey123!ChangeMeLater"
   "STORAGE_ACCOUNT_NAME"   = azurerm_storage_account.sa.name
   "STORAGE_CONTAINER_NAME" = azurerm_storage_container.raw_data_container.name
 }
 
 # Add explicit timeouts
 timeouts {
   create = "30m"
   delete = "30m"
 }
}

# 6. Data source to get the App Service with its identity
data "azurerm_linux_web_app" "api_app_data" {
 name                = azurerm_linux_web_app.api_app.name
 resource_group_name = azurerm_resource_group.rg.name

 depends_on = [azurerm_linux_web_app.api_app]
}

# 7. Get current client configuration (to get the current user's info)
data "azurerm_client_config" "current" {}

# 8. Grant App Service Managed Identity access to Storage Account
resource "azurerm_role_assignment" "adls_write_access" {
 scope                = azurerm_storage_account.sa.id                                    # The resource ID the role applies to (the storage account)
 role_definition_name = "Storage Blob Data Contributor"                                  # The role needed to write data
 principal_id         = data.azurerm_linux_web_app.api_app_data.identity[0].principal_id # The principal ID of the App Service's Managed Identity

 depends_on = [
   data.azurerm_linux_web_app.api_app_data,
   azurerm_storage_account.sa
 ]
}

# 9. Grant current user access to Storage Account (for development)
resource "azurerm_role_assignment" "current_user_access" {
 scope                = azurerm_storage_account.sa.id
 role_definition_name = "Storage Blob Data Contributor"
 principal_id         = data.azurerm_client_config.current.object_id

 # Optional: Add a description to clarify this is for development access
 description = "Grant developer access to storage account for testing and debugging"

 depends_on = [
   azurerm_storage_account.sa
 ]
}

# 10. Databricks Workspace
resource "azurerm_databricks_workspace" "databricks" {
 name                = "iot-azure-databricks-ned"  # Match the name in deploy.sh
 resource_group_name = azurerm_resource_group.rg.name
 location            = "eastus2"  # Match the location of other resources
 sku                 = "standard"

 tags = {
   Environment = "Development"
 }
 
 # Add explicit timeouts - longer for Databricks since it's more complex
 timeouts {
   create = "60m"
   delete = "60m"
 }
}

# 11. Output the Databricks Workspace URL
output "databricks_workspace_url" {
 value = azurerm_databricks_workspace.databricks.workspace_url
}

# 12. Output the Storage Account name 
output "storage_account_name" {
 value = azurerm_storage_account.sa.name
}

# 13. Output the Storage Account ID
output "storage_account_id" {
 value = azurerm_storage_account.sa.id
}

# 14. Output the Web App name
output "web_app_name" {
 value = azurerm_linux_web_app.api_app.name
}

# 15. Output the Resource Group name
output "resource_group_name" {
 value = azurerm_resource_group.rg.name
}# terraform/main.tf
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
  required_version = ">= 1.0"
}

# Configure the Azure Provider
provider "azurerm" {
  features {}
  # Assumes authentication via Azure CLI (run `az login`)
}

# --- Resource Definitions (Hardcoded) ---

# 1. Resource Group
resource "azurerm_resource_group" "rg" {
  name     = "iotdatabricksned" # Simple hardcoded name
  location = "eastus2"
}

# 2. ADLS Gen2 Storage Account
resource "azurerm_storage_account" "sa" {
  name                     = "iotlearn2024ned" # Updated to unique name
  resource_group_name      = azurerm_resource_group.rg.name
  location                 = azurerm_resource_group.rg.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
  is_hns_enabled           = true # Enable Hierarchical Namespace (ADLS Gen2)

  # Allow all network access for initial simplicity
  network_rules {
    default_action = "Allow"
    bypass         = ["AzureServices"]
  }
}

# 3. Storage Container
resource "azurerm_storage_container" "raw_data_container" {
  name                  = "rawdata"
  storage_account_name  = azurerm_storage_account.sa.name
  container_access_type = "private"
}

# 4. App Service Plan (Linux)
resource "azurerm_service_plan" "asp" {
  name                = "iot-azure-asp" # Simple hardcoded name
  resource_group_name = azurerm_resource_group.rg.name
  location            = azurerm_resource_group.rg.location
  os_type             = "Linux"
  sku_name            = "B1" # Basic tier
}

# 5. App Service (Linux Web App for .NET API)
resource "azurerm_linux_web_app" "api_app" {
  name                = "iot-azure-api-app-ned" # Consider making this dynamic/variable
  resource_group_name = azurerm_resource_group.rg.name
  location            = azurerm_resource_group.rg.location
  service_plan_id     = azurerm_service_plan.asp.id

  identity {
    type = "SystemAssigned"
  }

  site_config {
    application_stack {
      dotnet_version = "8.0" # Assuming .NET 8
    }
    always_on = false
  }

  app_settings = {
    # !! INSECURE - Hardcoded key for initial testing only !!
    # Consider using Key Vault reference later: "@Microsoft.KeyVault(SecretUri=...)"
    "APP_API_KEY"            = "SuperSecretKey123!ChangeMeLater"
    "STORAGE_ACCOUNT_NAME"   = azurerm_storage_account.sa.name
    "STORAGE_CONTAINER_NAME" = azurerm_storage_container.raw_data_container.name
  }
}

# 6. Data source to get the App Service with its identity
data "azurerm_linux_web_app" "api_app_data" {
  name                = azurerm_linux_web_app.api_app.name
  resource_group_name = azurerm_resource_group.rg.name

  depends_on = [azurerm_linux_web_app.api_app]
}

# 7. Get current client configuration (to get the current user's info)
data "azurerm_client_config" "current" {}

# 8. Grant App Service Managed Identity access to Storage Account
resource "azurerm_role_assignment" "adls_write_access" {
  scope                = azurerm_storage_account.sa.id                                    # The resource ID the role applies to (the storage account)
  role_definition_name = "Storage Blob Data Contributor"                                  # The role needed to write data
  principal_id         = data.azurerm_linux_web_app.api_app_data.identity[0].principal_id # The principal ID of the App Service's Managed Identity

  depends_on = [
    data.azurerm_linux_web_app.api_app_data,
    azurerm_storage_account.sa
  ]
}

# 9. Grant current user access to Storage Account (for development)
resource "azurerm_role_assignment" "current_user_access" {
  scope                = azurerm_storage_account.sa.id
  role_definition_name = "Storage Blob Data Contributor"
  principal_id         = data.azurerm_client_config.current.object_id

  # Optional: Add a description to clarify this is for development access
  description = "Grant developer access to storage account for testing and debugging"

  depends_on = [
    azurerm_storage_account.sa
  ]
}

# 10. Databricks Workspace
# Update the Databricks workspace resource in terraform/main.tf
resource "azurerm_databricks_workspace" "databricks" {
  name                = "iot-azure-databricks-ned"  # Match the name in deploy.sh
  resource_group_name = azurerm_resource_group.rg.name
  location            = "eastus2"  # Match the location of other resources
  sku                 = "standard"

  tags = {
    Environment = "Development"
  }
}

# 11. Output the Databricks Workspace URL
output "databricks_workspace_url" {
  value = azurerm_databricks_workspace.databricks.workspace_url
}{
  "version": 4,
  "terraform_version": "1.11.4",
  "serial": 1,
  "lineage": "58d1a00d-4032-39c6-946a-db8c654063c3",
  "outputs": {},
  "resources": [],
  "check_results": null
}


=== deploy.sh ===
#!/bin/bash

# Configuration
RESOURCE_GROUP="iot-azure-rg-1746834279"
APP_NAME="iot-azure-api-app-ned"
DATABRICKS_NAME="iot-azure-databricks-ned"
SUBSCRIPTION_ID="c1508b64-fb45-46f5-bf88-511ae65059d0"  # Extracted from error message
# REMOVED: STORAGE_ACCOUNT_NAME="iotlearn2024ned7a9b31c"  # This will come from Terraform output

# Check for --nuke flag
if [ "$1" == "--nuke" ]; then
    echo "Preparing for clean deployment..."
    
    # Check if resource group exists in Azure
    if az group show --name $RESOURCE_GROUP &>/dev/null; then
        echo "Resource group exists in Azure but may not be in Terraform state."
        
        # Initialize terraform
        cd terraform
        terraform init
        
        # Check if resource group is already in terraform state
        if ! terraform state list | grep -q "azurerm_resource_group.rg"; then
            echo "Importing existing resource group into Terraform state..."
            terraform import azurerm_resource_group.rg "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP"
        fi
        
        # Now destroy all resources
        echo "Running Terraform destroy to clean up resources..."
        terraform destroy -auto-approve
        
        cd ..
    else
        echo "Resource group doesn't exist in Azure, proceeding with clean deployment."
    fi
    
    # Ensure Terraform state is clean
    cd terraform
    rm -f .terraform/terraform.tfstate terraform.tfstate terraform.tfstate.backup 2>/dev/null || true
    cd ..
fi

# Apply Terraform for core resources first
echo "Creating/updating core infrastructure..."
cd terraform
terraform init

# Check if resource group exists but isn't in Terraform state
if az group show --name $RESOURCE_GROUP &>/dev/null && ! terraform state list 2>/dev/null | grep -q "azurerm_resource_group.rg"; then
    echo "Resource group exists in Azure but not in Terraform state. Importing..."
    terraform import azurerm_resource_group.rg "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP"
fi

# Apply only resource group and storage account first
echo "Creating resource group and storage account..."
terraform apply -auto-approve -target=azurerm_resource_group.rg -target=azurerm_storage_account.sa

# Check if storage account was created - IMPROVED VERSION
echo "Verifying storage account creation..."
# CHANGED: Always get from terraform output (no fallback to hardcoded value)
STORAGE_ACCOUNT=$(terraform output -raw storage_account_name)
echo "Storage account name: $STORAGE_ACCOUNT"

# Wait for storage account to be fully provisioned with improved logic
echo "Waiting for storage account to be fully provisioned..."
MAX_RETRIES=15  # Increased from 10 to 15
RETRY_COUNT=0

# First check if resource exists without trying to get properties
while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if az resource show --resource-group $RESOURCE_GROUP --name $STORAGE_ACCOUNT --resource-type "Microsoft.Storage/storageAccounts" &>/dev/null; then
        echo "Storage account exists in Azure! Checking if fully provisioned..."
        break
    fi
    
    RETRY_COUNT=$((RETRY_COUNT+1))
    if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
        echo "Storage account existence check timed out after $MAX_RETRIES retries."
        echo "This might be due to ARM API propagation delay."
        echo "Continuing with deployment anyway, but some resources might fail."
        break
    fi
    
    echo "Storage account not yet visible in Azure. Waiting 20 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
    sleep 20
done

# If we found the storage account, check if it's fully provisioned
if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
    echo "Storage account found! Continuing with deployment."
fi

# Apply the rest of Terraform
echo "Creating remaining infrastructure..."
terraform apply -auto-approve
cd ..

# Deploy the app
echo "Building app..."
cd src
dotnet publish -c Release -o ./publish

echo "Creating deployment package..."
cd publish
# Clean up any old deployment packages
rm -f ../deploy.zip 2>/dev/null || true
# Create a fresh package without recursive publish folders
zip -r ../deploy.zip * -x "publish/*"
cd ..

# Wait a bit for resources to be fully provisioned
echo "Waiting for resources to be fully provisioned..."
sleep 30

# Check if app exists before deploying
echo "Checking if app exists before deploying..."
if az webapp show --resource-group $RESOURCE_GROUP --name $APP_NAME &>/dev/null; then
    echo "Deploying to Azure..."
    az webapp deploy --resource-group $RESOURCE_GROUP \
      --name $APP_NAME \
      --src-path ./deploy.zip \
      --type zip
else
    echo "Warning: Web app $APP_NAME not found in resource group $RESOURCE_GROUP"
    echo "This may be normal if Terraform is still provisioning resources."
    echo "Try running the following command when resources are ready:"
    echo "az webapp deploy --resource-group $RESOURCE_GROUP --name $APP_NAME --src-path ./src/deploy.zip --type zip"
fi

# Display Databricks workspace information (if available)
echo "Checking Databricks workspace information..."
if az databricks workspace show --resource-group $RESOURCE_GROUP --name $DATABRICKS_NAME &>/dev/null; then
    echo "Databricks workspace URL:"
    az databricks workspace show --resource-group $RESOURCE_GROUP --name $DATABRICKS_NAME --query workspaceUrl -o tsv
else
    echo "Databricks workspace not yet available. It may still be provisioning."
fi

# Optionally tail logs if web app exists
if az webapp show --resource-group $RESOURCE_GROUP --name $APP_NAME &>/dev/null; then
    echo "Tailing API logs..."
    az webapp log tail --resource-group $RESOURCE_GROUP --name $APP_NAME
else
    echo "Web app not yet available for log tailing."
fi

echo "Deployment script completed."

=== appsettings.json ===
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}


=== tfplan ===


=== Azure Resource Group Status ===
Deleting
